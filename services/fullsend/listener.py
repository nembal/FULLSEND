"""FULLSEND Listener - central coordinator for the experiment lifecycle.

Subscribes to:
- fullsend:to_fullsend - incoming experiment requests
- fullsend:builder_results - tool build completions
- fullsend:experiment_results - execution results

Handles the full loop:
1. Receives experiment requests → spawns Claude Code
2. When tools are built → triggers pending experiments
3. When experiments fail → routes errors appropriately:
   - ToolNotFoundError → auto-requests tool build
   - API key errors → escalates to user via Discord
   - Other errors → notifies orchestrator

Usage:
    uv run python -m services.fullsend.listener
"""

import asyncio
import json
import logging
import os
import re
import subprocess
import sys
from datetime import UTC, datetime
from pathlib import Path

import redis.asyncio as redis

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)

# Paths
SERVICE_DIR = Path(__file__).parent
REQUESTS_DIR = SERVICE_DIR / "requests"
CURRENT_MD = REQUESTS_DIR / "current.md"
RUN_SH = SERVICE_DIR / "run.sh"
RALPH_SH = SERVICE_DIR / "ralph.sh"

# Redis config
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
CHANNEL_TO_FULLSEND = "fullsend:to_fullsend"
CHANNEL_TO_ORCHESTRATOR = "fullsend:to_orchestrator"
CHANNEL_BUILDER_RESULTS = "fullsend:builder_results"
CHANNEL_EXPERIMENT_RESULTS = "fullsend:experiment_results"
CHANNEL_EXECUTE_NOW = "fullsend:execute_now"
CHANNEL_BUILDER_TASKS = "fullsend:builder_tasks"

# Execution timeout (Claude Code can take a while)
EXECUTION_TIMEOUT = int(os.getenv("FULLSEND_TIMEOUT", "600"))  # 10 minutes default


async def write_request(request: dict) -> Path:
    """Write incoming request to current.md."""
    # Extract the actual content
    idea = request.get("idea", {})
    context = request.get("context", "")
    priority = request.get("priority", "medium")
    reasoning = request.get("orchestrator_reasoning", "")
    
    # Format as markdown
    content = f"""# Experiment Request

**Priority:** {priority}
**Received:** {datetime.now(UTC).isoformat()}

## Idea/Goal
{json.dumps(idea, indent=2) if isinstance(idea, dict) else idea}

## Context
{context}

## Orchestrator Reasoning
{reasoning}

---
*Auto-generated by FULLSEND listener from Redis message*
"""
    
    # Write to file
    REQUESTS_DIR.mkdir(parents=True, exist_ok=True)
    CURRENT_MD.write_text(content)
    logger.info(f"Wrote request to {CURRENT_MD}")
    return CURRENT_MD


async def run_fullsend(request: dict) -> dict:
    """Run FULLSEND Claude Code and capture result."""
    # Check if this needs RALPH (complex multi-step task)
    idea = request.get("idea", {})
    use_ralph = False
    ralph_goal = ""
    
    if isinstance(idea, dict):
        use_ralph = idea.get("spawn_ralph", False)
        ralph_goal = idea.get("goal", idea.get("description", ""))
    elif isinstance(idea, str) and "RALPH" in idea.upper():
        use_ralph = True
        ralph_goal = idea
    
    try:
        if use_ralph and ralph_goal:
            logger.info(f"Spawning RALPH loop for: {ralph_goal[:100]}...")
            result = await asyncio.wait_for(
                asyncio.to_thread(
                    _run_subprocess,
                    [str(RALPH_SH), "spawn", ralph_goal],
                ),
                timeout=EXECUTION_TIMEOUT,
            )
        else:
            logger.info("Running FULLSEND (run.sh)...")
            result = await asyncio.wait_for(
                asyncio.to_thread(
                    _run_subprocess,
                    [str(RUN_SH)],
                ),
                timeout=EXECUTION_TIMEOUT,
            )
        
        return {
            "success": result["returncode"] == 0,
            "output": result["stdout"][-2000:] if result["stdout"] else "",
            "error": result["stderr"][-1000:] if result["stderr"] else "",
            "returncode": result["returncode"],
        }
        
    except asyncio.TimeoutError:
        logger.error(f"FULLSEND timed out after {EXECUTION_TIMEOUT}s")
        return {
            "success": False,
            "error": f"Execution timed out after {EXECUTION_TIMEOUT}s",
            "returncode": -1,
        }
    except Exception as e:
        logger.error(f"FULLSEND failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "returncode": -1,
        }


def _run_subprocess(cmd: list) -> dict:
    """Run subprocess and capture output (blocking, called in thread)."""
    logger.info(f"Executing: {' '.join(cmd)}")
    
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        cwd=SERVICE_DIR,
        timeout=EXECUTION_TIMEOUT,
    )
    
    return {
        "stdout": result.stdout,
        "stderr": result.stderr,
        "returncode": result.returncode,
    }


async def notify_orchestrator(
    redis_client: redis.Redis,
    msg_type: str,
    payload: dict,
) -> None:
    """Send notification back to Orchestrator."""
    message = {
        "type": msg_type,
        "source": "fullsend_listener",
        "timestamp": datetime.now(UTC).isoformat(),
        **payload,
    }
    await redis_client.publish(CHANNEL_TO_ORCHESTRATOR, json.dumps(message))
    logger.info(f"Notified orchestrator: {msg_type}")


async def trigger_execution(redis_client: redis.Redis, experiment_id: str) -> None:
    """Trigger immediate execution of an experiment."""
    message = {
        "experiment_id": experiment_id,
        "triggered_by": "fullsend_listener",
        "timestamp": datetime.now(UTC).isoformat(),
    }
    await redis_client.publish(CHANNEL_EXECUTE_NOW, json.dumps(message))
    logger.info(f"Triggered execution: {experiment_id}")


async def store_pending_experiment(
    redis_client: redis.Redis,
    experiment_id: str,
    required_tool: str,
) -> None:
    """Store experiment as pending until tool is built."""
    key = f"pending_experiments:{required_tool}"
    await redis_client.sadd(key, experiment_id)
    logger.info(f"Experiment {experiment_id} pending tool: {required_tool}")


async def get_pending_experiment_for_tool(
    redis_client: redis.Redis,
    tool_name: str,
) -> dict | None:
    """Get and remove pending experiment for a tool."""
    key = f"pending_experiments:{tool_name}"
    exp_id = await redis_client.spop(key)
    if exp_id:
        return {"experiment_id": exp_id}
    return None


async def request_tool_build(
    redis_client: redis.Redis,
    tool_name: str,
    experiment_id: str,
) -> None:
    """Request Builder to create a missing tool."""
    # Store experiment as pending
    await store_pending_experiment(redis_client, experiment_id, tool_name)

    # Request tool build
    message = {
        "prd": {
            "tool_name": tool_name,
            "description": f"Tool required by experiment {experiment_id}",
            "auto_requested": True,
        },
        "requested_by": "fullsend_listener",
        "request_id": f"auto_{experiment_id}_{tool_name}",
    }
    await redis_client.publish(CHANNEL_BUILDER_TASKS, json.dumps(message))
    logger.info(f"Requested tool build: {tool_name} for experiment {experiment_id}")


def _extract_tool_name_from_error(error: str) -> str | None:
    """Extract tool name from a ToolNotFoundError message."""
    # Common patterns: "Tool 'xyz' not found", "ToolNotFoundError: xyz"
    patterns = [
        r"Tool '([^']+)' not found",
        r"Tool \"([^\"]+)\" not found",
        r"ToolNotFoundError:\s*(\w+)",
        r"tool[_\s]?name[:\s]+['\"]?(\w+)",
    ]
    for pattern in patterns:
        match = re.search(pattern, error, re.IGNORECASE)
        if match:
            return match.group(1)
    return None


async def handle_builder_result(data: dict, redis_client: redis.Redis) -> None:
    """Handle builder completion - trigger pending experiment execution."""
    msg_type = data.get("type")
    tool_name = data.get("tool_name")
    request_id = data.get("request_id")

    if msg_type == "tool_built":
        logger.info(f"Tool built: {tool_name}")

        # Check for pending experiment that needed this tool
        pending = await get_pending_experiment_for_tool(redis_client, tool_name)
        if pending:
            logger.info(f"Found pending experiment for {tool_name}, triggering execution")
            await trigger_execution(redis_client, pending["experiment_id"])
        else:
            logger.info(f"No pending experiment for tool {tool_name}")

    elif msg_type == "tool_build_failed":
        error = data.get("error", "Unknown error")
        logger.error(f"Tool build failed: {tool_name} - {error}")
        # Notify orchestrator of build failure
        await notify_orchestrator(redis_client, "tool_build_failed", {
            "tool_name": tool_name,
            "error": error,
            "request_id": request_id,
        })


async def handle_experiment_result(data: dict, redis_client: redis.Redis) -> None:
    """Handle execution result - log success or handle failure."""
    msg_type = data.get("type")
    exp_id = data.get("experiment_id")
    run_id = data.get("run_id")

    if msg_type == "experiment_completed":
        logger.info(f"Experiment completed: {exp_id}")
        await notify_orchestrator(redis_client, "experiment_success", {
            "experiment_id": exp_id,
            "run_id": run_id,
            "duration": data.get("duration"),
        })

    elif msg_type == "experiment_failed":
        error = data.get("error", "Unknown error")
        error_type = data.get("error_type", "Unknown")

        logger.error(f"Experiment failed: {exp_id} - {error_type}: {error}")

        # Determine action based on error type
        if error_type == "ToolNotFoundError":
            # Tool missing - request build
            tool_name = _extract_tool_name_from_error(error)
            if tool_name:
                logger.info(f"Missing tool detected: {tool_name}, requesting build")
                await request_tool_build(redis_client, tool_name, exp_id)
            else:
                logger.warning(f"Could not extract tool name from error: {error}")
                await notify_orchestrator(redis_client, "experiment_error", {
                    "experiment_id": exp_id,
                    "error": error,
                    "error_type": error_type,
                    "note": "Could not auto-request tool build",
                })

        elif any(kw in error.lower() for kw in ["api", "key", "unauthorized", "401", "403"]):
            # API key issue - escalate to user via Orchestrator
            await notify_orchestrator(redis_client, "api_key_required", {
                "experiment_id": exp_id,
                "error": error,
                "suggestion": "Please set the required API key in .env",
            })

        else:
            # Code bug or other issue - notify for investigation
            await notify_orchestrator(redis_client, "experiment_error", {
                "experiment_id": exp_id,
                "run_id": run_id,
                "error": error,
                "error_type": error_type,
            })


async def process_request(
    request: dict,
    redis_client: redis.Redis,
) -> None:
    """Process a single FULLSEND request."""
    request_id = request.get("request_id", datetime.now(UTC).strftime("%Y%m%d_%H%M%S"))
    logger.info(f"Processing request: {request_id}")
    
    # Notify start
    await notify_orchestrator(redis_client, "fullsend_started", {
        "request_id": request_id,
    })
    
    # Write request to file
    await write_request(request)
    
    # Run FULLSEND
    result = await run_fullsend(request)
    
    # Notify completion
    if result["success"]:
        await notify_orchestrator(redis_client, "fullsend_completed", {
            "request_id": request_id,
            "output_preview": result.get("output", "")[:500],
        })
        logger.info(f"Request completed successfully: {request_id}")
    else:
        await notify_orchestrator(redis_client, "fullsend_failed", {
            "request_id": request_id,
            "error": result.get("error", "Unknown error"),
        })
        logger.error(f"Request failed: {request_id} - {result.get('error')}")


async def main() -> None:
    """Main listener loop."""
    logger.info("=" * 60)
    logger.info("Starting FULLSEND Listener")
    logger.info("=" * 60)
    logger.info(f"Redis: {REDIS_URL}")
    logger.info(f"Channels: {CHANNEL_TO_FULLSEND}, {CHANNEL_BUILDER_RESULTS}, {CHANNEL_EXPERIMENT_RESULTS}")
    logger.info(f"Timeout: {EXECUTION_TIMEOUT}s")
    logger.info(f"Service dir: {SERVICE_DIR}")
    logger.info("=" * 60)

    # Connect to Redis
    redis_client = redis.from_url(REDIS_URL, decode_responses=True)
    pubsub = redis_client.pubsub()

    channels = [CHANNEL_TO_FULLSEND, CHANNEL_BUILDER_RESULTS, CHANNEL_EXPERIMENT_RESULTS]

    try:
        # Test connection
        await redis_client.ping()
        logger.info("Connected to Redis")

        # Subscribe to all channels
        await pubsub.subscribe(*channels)
        for ch in channels:
            logger.info(f"Subscribed to {ch}")
        logger.info("Waiting for messages...")

        async for message in pubsub.listen():
            if message["type"] != "message":
                continue

            channel = message.get("channel", "")
            if isinstance(channel, bytes):
                channel = channel.decode()

            try:
                data = json.loads(message["data"])

                if channel == CHANNEL_TO_FULLSEND:
                    await process_request(data, redis_client)
                elif channel == CHANNEL_BUILDER_RESULTS:
                    await handle_builder_result(data, redis_client)
                elif channel == CHANNEL_EXPERIMENT_RESULTS:
                    await handle_experiment_result(data, redis_client)
                else:
                    logger.warning(f"Unknown channel: {channel}")

            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse message: {e}")
            except Exception as e:
                logger.error(f"Error processing message on {channel}: {e}", exc_info=True)

    except KeyboardInterrupt:
        logger.info("Shutting down FULLSEND Listener...")
    finally:
        await pubsub.unsubscribe(*channels)
        await redis_client.aclose()
        logger.info("FULLSEND Listener stopped")


if __name__ == "__main__":
    asyncio.run(main())
